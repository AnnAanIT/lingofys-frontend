
import { 
  User, UserRole, Mentor, Booking, BookingStatus, Homework, 
  AvailabilitySlot, Conversation, Message, Notification, 
  Transaction, Payout, SystemLog, CreditHistoryEntry, 
  Subscription, SubscriptionPlan, MentorEarning, 
  SystemCreditLedgerEntry, Provider, Referral, 
  ProviderCommission, PricingCountry, PricingGroup, 
  SystemSettings, ProviderLevel, WeeklyRevenueResponse, MonthlyRevenueResponse, CACDashboardData
} from '../types';
import { 
  INITIAL_USERS, INITIAL_MENTORS, INITIAL_BOOKINGS, 
  INITIAL_HOMEWORK, 
  INITIAL_CONVERSATIONS, INITIAL_MESSAGES, INITIAL_PROVIDERS, 
  INITIAL_SYSTEM_CREDIT_LEDGER, 
  INITIAL_PAYOUTS, INITIAL_TRANSACTIONS, INITIAL_REFERRALS, 
  INITIAL_COMMISSIONS, INITIAL_LOGS, INITIAL_NOTIFICATIONS, 
  SUBSCRIPTION_PLANS, INITIAL_CREDIT_HISTORY,
  INITIAL_SETTINGS, INITIAL_PRICING_COUNTRIES, INITIAL_PRICING_GROUPS,
  INITIAL_PROVIDER_LEVELS
} from '../mockData';

import { creditPendingServiceV2 } from './v2/creditPendingServiceV2';
import { mentorPayoutServiceV2 } from './v2/mentorPayoutServiceV2';
import { providerCommissionServiceV2 } from './v2/providerCommissionServiceV2';
import { pricingRevenueServiceV2 } from './v2/pricingRevenueServiceV2';
import { notificationService } from './v2/notificationService';
import { getTimezoneByCountry, validateTimezone } from '../lib/timeUtils';
import { security } from '../utils/security';

const API_DELAY = 400;

// ===== BACKEND API CONFIGURATION =====
// Vite uses import.meta.env instead of process.env
const API_BASE_URL = (import.meta.env.VITE_API_URL as string | undefined) || 'http://localhost:3001';

// Helper: Build full API URL
const buildUrl = (path: string): string => `${API_BASE_URL}${path}`;

// Helper: Get auth token from localStorage
const getAuthToken = (): string | null => {
  return localStorage.getItem('authToken');
};

// Helper: Get refresh token from localStorage
const getRefreshToken = (): string | null => {
  return localStorage.getItem('refreshToken');
};

// Helper: Set tokens in localStorage
const setTokens = (token: string, refreshToken: string): void => {
  localStorage.setItem('authToken', token);
  localStorage.setItem('refreshToken', refreshToken);
};

// Helper: Clear all auth data
const clearAuthData = (): void => {
  localStorage.removeItem('authToken');
  localStorage.removeItem('refreshToken');
  localStorage.removeItem('user');
};

// Helper: Refresh access token using refresh token
const refreshAccessToken = async (): Promise<boolean> => {
  const refreshToken = getRefreshToken();
  if (!refreshToken) {
    return false;
  }

  try {
    const response = await fetch(buildUrl('/api/auth/refresh'), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken })
    });

    if (!response.ok) {
      return false;
    }

    const data = await response.json();
    setTokens(data.token, data.refreshToken);
    return true;
  } catch (error) {
    console.error('Failed to refresh token:', error);
    return false;
  }
};

// Helper: Authenticated fetch with JWT token and auto-refresh
const authenticatedFetch = async (url: string, options: RequestInit = {}): Promise<Response> => {
  let token = getAuthToken();
  if (!token) {
    throw new Error('Not authenticated. Please login first.');
  }

  // First attempt with current token
  let response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  });

  // If 401, try to refresh token and retry
  if (response.status === 401) {
    const refreshed = await refreshAccessToken();

    if (refreshed) {
      // Retry with new token
      token = getAuthToken();
      response = await fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
    } else {
      // Refresh failed, clear auth and redirect to login
      clearAuthData();
      throw new Error('Session expired. Please login again.');
    }
  }

  return response;
};

// Helper: Handle API errors
const handleApiError = async (response: Response): Promise<never> => {
  // Try to parse error message from response
  const errorData = await response.json().catch(() => ({ message: 'Unknown error occurred' }));

  // Auto-logout on 401 Unauthorized
  if (response.status === 401) {
    clearAuthData();
    // Redirect to login after short delay
    setTimeout(() => {
      window.location.href = '/#/login';
    }, 1000);
    throw new Error(errorData.message || 'Session expired. Please login again.');
  }

  throw new Error(errorData.message || `API Error: ${response.status}`);
};

// ===== MOCKDB (LEGACY - BEING PHASED OUT) =====
class MockDB {
    get<T>(key: string, initial: T): T {
        const s = localStorage.getItem(key);
        if (!s) {
            this.set(key, initial);
            return initial;
        }
        return JSON.parse(s);
    }
    set(key: string, data: any) {
        localStorage.setItem(key, JSON.stringify(data));
    }
    reset() {
        localStorage.clear();
        window.location.reload();
    }
}

const db = new MockDB();

const apiCall = async <T>(fn: () => T | Promise<T>): Promise<T> => {
    return new Promise((resolve, reject) => {
        setTimeout(async () => {
            try {
                const result = await fn();
                resolve(result);
            } catch (error) {
                reject(error);
            }
        }, API_DELAY);
    });
};

// --- INTERNAL NOTIFICATION HELPER ---
// ‚ö†Ô∏è DEPRECATED: Use notificationService instead for i18n support
const triggerNotification = (notif: Omit<Notification, 'id' | 'createdAt' | 'read'>) => {
    console.warn('‚ö†Ô∏è triggerNotification is deprecated. Use notificationService for i18n support.');
    const ns = db.get<Notification[]>('notifications', INITIAL_NOTIFICATIONS);
    ns.unshift({
        ...notif,
        id: `nt_${Date.now()}_${Math.random().toString(36).substr(2, 4)}`,
        createdAt: new Date().toISOString(),
        read: false
    });
    db.set('notifications', ns);
};

export const api = {
  resetDatabase: () => db.reset(),

  // --- AUTH ---
  login: async (email: string, password: string): Promise<User> => {
    // NEW: Backend API login
    const response = await fetch(buildUrl('/api/auth/login'), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();

    // Store both access token and refresh token
    setTokens(data.token, data.refreshToken);

    // Cache user data for session persistence
    localStorage.setItem('user', JSON.stringify(data.user));

    // Return only user object (matching existing interface)
    return data.user;
  },

  // OLD MOCKDB LOGIN - KEPT FOR ROLLBACK
  // login: async (email: string, password?: string): Promise<User> => {
  //   return apiCall(async () => {
  //       // ‚úÖ FIX BUG #9: Add rate limiting
  //       try {
  //           security.checkLoginRateLimit(email);
  //       } catch (e: any) {
  //           throw new Error(e.message);
  //       }
  //
  //       const users = db.get<User[]>('users', INITIAL_USERS);
  //       const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
  //       if (!user) throw new Error("Email kh√¥ng t·ªìn t·∫°i.");
  //
  //       // ‚úÖ FIX BUG #9: Verify password hash instead of plaintext comparison
  //       if (password && user.password) {
  //           // Support both hashed and legacy plaintext passwords
  //           const isValid = user.password.startsWith('sha256:')
  //               ? await security.verifyPassword(password, user.password)
  //               : user.password === password; // Legacy plaintext fallback
  //
  //           if (!isValid) {
  //               throw new Error("M·∫≠t kh·∫©u kh√¥ng kh·ªõp.");
  //           }
  //       }
  //
  //       // ‚úÖ Check user status before allowing login
  //       if (user.status === 'PENDING_APPROVAL') {
  //           throw new Error("T√†i kho·∫£n c·ªßa b·∫°n ƒëang ch·ªù admin ph√™ duy·ªát. Vui l√≤ng ki·ªÉm tra email ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.");
  //       }
  //       if (user.status === 'REJECTED') {
  //           throw new Error(`T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã t·ª´ ch·ªëi. L√Ω do: ${user.rejectionReason || 'Kh√¥ng r√µ'}. B·∫°n c√≥ th·ªÉ ƒëƒÉng k√Ω l·∫°i.`);
  //       }
  //       if (user.status === 'BANNED') {
  //           throw new Error("T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a. Vui l√≤ng li√™n h·ªá admin.");
  //       }
  //
  //       // ‚úÖ Reset rate limit on successful login
  //       security.resetLoginRateLimit(email);
  //
  //       return user;
  //   });
  // },

  loginById: async (id: string): Promise<User> => {
    return apiCall(() => {
        const users = db.get<User[]>('users', INITIAL_USERS);
        const user = users.find(u => u.id === id);
        if (!user) throw new Error("User not found");
        return user;
    });
  },

  loginByRole: async (role: UserRole): Promise<User> => {
    return apiCall(() => {
        const users = db.get<User[]>('users', INITIAL_USERS);
        const user = users.find(u => u.role === role);
        if (!user) throw new Error("Role not found");
        return user;
    });
  },

  register: async (data: any): Promise<User> => {
    // NEW: Backend API register
    const response = await fetch(buildUrl('/api/auth/register'), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: data.email,
        password: data.password,
        name: data.name,
        role: data.role,
        country: data.country || 'VN'
      })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const result = await response.json();

    // Return user (backend automatically creates mentor/provider profiles)
    return result.user;
  },

  // OLD MOCKDB REGISTER - KEPT FOR ROLLBACK
  // register: async (data: any): Promise<User> => {
  //   return apiCall(async () => {
  //       const users = db.get<User[]>('users', INITIAL_USERS);
  //
  //       // ‚úÖ Allow re-registration if previous account was REJECTED
  //       const existingUser = users.find(u => u.email === data.email);
  //       if (existingUser && existingUser.status !== 'REJECTED') {
  //           throw new Error("Email ƒë√£ t·ªìn t·∫°i.");
  //       }
  //
  //       const country = data.country || 'VN';
  //       const timezone = getTimezoneByCountry(country);
  //
  //       // ‚úÖ FIX BUG #9: Hash password before storing
  //       const hashedPassword = await security.hashPassword(data.password);
  //
  //       // ‚úÖ Set status based on role: MENTEE = ACTIVE, MENTOR/PROVIDER = PENDING_APPROVAL
  //       const status: 'ACTIVE' | 'PENDING_APPROVAL' =
  //           data.role === UserRole.MENTEE ? 'ACTIVE' : 'PENDING_APPROVAL';
  //
  //       let newUser: User;
  //
  //       // ‚úÖ Re-apply logic: Update existing REJECTED user instead of creating new one
  //       if (existingUser && existingUser.status === 'REJECTED') {
  //           const userIdx = users.findIndex(u => u.email === data.email);
  //           users[userIdx] = {
  //               ...existingUser,
  //               name: data.name,
  //               password: hashedPassword,
  //               role: data.role,
  //               status: status,
  //               rejectionReason: undefined, // Clear old rejection reason
  //               appliedAt: status === 'PENDING_APPROVAL' ? new Date().toISOString() : undefined,
  //               country: country,
  //               timezone: timezone
  //           };
  //           newUser = users[userIdx];
  //           db.set('users', users);
  //       } else {
  //           // New registration
  //           newUser = {
  //               id: `u_${Date.now()}`,
  //               name: data.name,
  //               email: data.email,
  //               password: hashedPassword,
  //               role: data.role,
  //               avatar: `https://ui-avatars.com/api/?name=${encodeURIComponent(data.name)}&background=random`,
  //               credits: 0,
  //               balance: 0,
  //               status: status,
  //               joinedAt: new Date().toISOString(),
  //               country: country,
  //               timezone: timezone,
  //               appliedAt: status === 'PENDING_APPROVAL' ? new Date().toISOString() : undefined
  //           };
  //           users.push(newUser);
  //           db.set('users', users);
  //       }
  //
  //       // ‚úÖ Send email notification to admin for MENTOR/PROVIDER registration
  //       if (data.role === UserRole.MENTOR || data.role === UserRole.PROVIDER) {
  //           console.log(`üìß [EMAIL NOTIFICATION] New ${data.role} application received`);
  //           console.log(`   To: admin@englishplatform.com`);
  //           console.log(`   Subject: New ${data.role} Registration - Pending Approval`);
  //           console.log(`   Body: ${data.name} (${data.email}) has registered as ${data.role}. Please review and approve.`);
  //
  //           // Create admin notification
  //           triggerNotification({
  //               role: UserRole.ADMIN,
  //               userId: 'ALL',
  //               type: 'info',
  //               title: `New ${data.role} Application`,
  //               message: `${data.name} (${data.email}) has registered as ${data.role}. Pending approval.`,
  //               actionType: 'system',
  //               actionId: newUser.id
  //           });
  //       }
  //
  //       if (data.role === UserRole.MENTOR) {
  //           const mentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
  //           const existingMentorIdx = mentors.findIndex(m => m.id === newUser.id);
  //
  //           if (existingMentorIdx !== -1) {
  //               // ‚úÖ Update existing mentor (re-apply case)
  //               mentors[existingMentorIdx] = {
  //                   ...mentors[existingMentorIdx],
  //                   ...newUser,
  //                   // Preserve mentor-specific fields if they exist
  //                   bio: mentors[existingMentorIdx].bio || 'New mentor',
  //                   specialties: mentors[existingMentorIdx].specialties || [],
  //                   hourlyRate: mentors[existingMentorIdx].hourlyRate || 10,
  //                   rating: mentors[existingMentorIdx].rating || 5,
  //                   reviewCount: mentors[existingMentorIdx].reviewCount || 0,
  //                   experienceYears: mentors[existingMentorIdx].experienceYears || 0,
  //                   availability: mentors[existingMentorIdx].availability || []
  //               };
  //           } else {
  //               // ‚úÖ Create new mentor entry
  //               mentors.push({
  //                   ...newUser,
  //                   bio: 'New mentor',
  //                   specialties: [],
  //                   hourlyRate: 10,
  //                   rating: 5,
  //                   reviewCount: 0,
  //                   experienceYears: 0,
  //                   availability: []
  //               });
  //           }
  //           db.set('mentors', mentors);
  //       }
  //       return newUser;
  //   });
  // },

  // --- AVAILABILITY ---

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getAvailability: async (mentorId: string) => apiCall(() => {
  //     const mentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
  //     return mentors.find(m => m.id === mentorId)?.availability || [];
  // }),

  // NEW BACKEND API CODE
  getAvailability: async (mentorId: string): Promise<AvailabilitySlot[]> => {
    const response = await fetch(buildUrl(`/api/mentors/${mentorId}/availability`));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.availability || [];
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // addAvailability: async (mentorId: string, slot: Omit<AvailabilitySlot, 'id' | 'mentorId'>) => apiCall(() => {
  //     const mentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
  //     const mIdx = mentors.findIndex(m => m.id === mentorId);
  //     if (mIdx === -1) throw new Error("Mentor not found");
  //
  //     const newSlot: AvailabilitySlot = {
  //         ...slot,
  //         id: `av_${Date.now()}`,
  //         mentorId
  //     };
  //
  //     if (!mentors[mIdx].availability) mentors[mIdx].availability = [];
  //     mentors[mIdx].availability.push(newSlot);
  //     db.set('mentors', mentors);
  //     return newSlot;
  // }),

  // NEW BACKEND API CODE - Use updateAvailability with full array instead
  addAvailability: async (mentorId: string, slot: Omit<AvailabilitySlot, 'id' | 'mentorId'>): Promise<AvailabilitySlot> => {
    // Get current availability
    const current = await api.getAvailability(mentorId);

    // Add new slot
    const newSlot: AvailabilitySlot = {
      ...slot,
      id: `av_${Date.now()}`,
      mentorId
    };

    // Update with full array including new slot
    const updated = await api.updateAvailability(mentorId, [...current, newSlot]);

    return newSlot;
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // updateAvailability: async (mentorId: string, slotId: string, updates: Partial<AvailabilitySlot>) => apiCall(() => {
  //     const mentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
  //     const mIdx = mentors.findIndex(m => m.id === mentorId);
  //     if (mIdx === -1) return;
  //
  //     const sIdx = mentors[mIdx].availability.findIndex(s => s.id === slotId);
  //     if (sIdx !== -1) {
  //         mentors[mIdx].availability[sIdx] = { ...mentors[mIdx].availability[sIdx], ...updates };
  //         db.set('mentors', mentors);
  //     }
  // }),

  // NEW BACKEND API CODE - Supports both signatures for backward compatibility
  updateAvailability: async (
    mentorId: string,
    slotIdOrAvailability: string | AvailabilitySlot[],
    updates?: Partial<AvailabilitySlot>
  ): Promise<AvailabilitySlot[] | void> => {
    let availability: AvailabilitySlot[];

    if (typeof slotIdOrAvailability === 'string') {
      // Old signature: updateAvailability(mentorId, slotId, updates)
      const current = await api.getAvailability(mentorId);
      const slotId = slotIdOrAvailability;
      const sIdx = current.findIndex(s => s.id === slotId);

      if (sIdx !== -1 && updates) {
        current[sIdx] = { ...current[sIdx], ...updates };
      }

      availability = current;
    } else {
      // New signature: updateAvailability(mentorId, availability)
      availability = slotIdOrAvailability;
    }

    const response = await authenticatedFetch(buildUrl(`/api/mentors/${mentorId}/availability`), {
      method: 'PUT',
      body: JSON.stringify({ availability })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.availability || [];
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // deleteAvailability: async (mentorId: string, slotId: string) => apiCall(() => {
  //     const mentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
  //     const mIdx = mentors.findIndex(m => m.id === mentorId);
  //     if (mIdx === -1) return;
  //
  //     mentors[mIdx].availability = mentors[mIdx].availability.filter(s => s.id !== slotId);
  //     db.set('mentors', mentors);
  // }),

  // NEW BACKEND API CODE - Use updateAvailability with filtered array instead
  deleteAvailability: async (mentorId: string, slotId: string): Promise<void> => {
    // Get current availability
    const current = await api.getAvailability(mentorId);

    // Filter out the slot to delete
    const updated = current.filter(s => s.id !== slotId);

    // Update with filtered array
    await api.updateAvailability(mentorId, updated);
  },

  // --- WALLET & CREDITS ---
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // buyCredits: async (userId: string, amount: number, method: string) => apiCall(async () => {
  //   const users = db.get<User[]>('users', INITIAL_USERS);
  //   const idx = users.findIndex(u => u.id === userId);
  //   if (idx === -1) throw new Error("User not found");
  //   const settings = db.get<SystemSettings>('systemSettings', INITIAL_SETTINGS);
  //   const ratio = settings.topupConversionRatio || 0.8;
  //   const creditsToAdd = Number((amount * ratio).toFixed(2));
  //   users[idx].credits += creditsToAdd;
  //   db.set('users', users);
  //   const history = db.get<CreditHistoryEntry[]>('creditHistory', INITIAL_CREDIT_HISTORY);
  //   history.unshift({
  //       id: `ch_${Date.now()}`,
  //       userId,
  //       type: 'topup',
  //       amount: creditsToAdd,
  //       balanceAfter: users[idx].credits,
  //       note: `N·∫°p $${amount} USD = ${creditsToAdd} Credits qua ${method}`,
  //       timestamp: new Date().toISOString()
  //   });
  //   db.set('creditHistory', history);
  //   const txs = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS);
  //   txs.push({
  //       id: `tx_topup_${Date.now()}`,
  //       userId,
  //       amount: amount,
  //       type: 'TOPUP',
  //       description: `Credit Top-up: $${amount} USD = ${creditsToAdd} Credits via ${method}`,
  //       date: new Date().toISOString(),
  //       status: 'COMPLETED'
  //   });
  //   db.set('transactions', txs);
  //   await notificationService.notifyCreditChange(userId, UserRole.MENTEE, creditsToAdd, 'topup');
  // }),

  // NEW BACKEND API CODE - Create Stripe checkout session
  buyCredits: async (userId: string, amount: number, currency: string = 'USD'): Promise<{ url: string }> => {
    const response = await authenticatedFetch(buildUrl('/api/topup/create-session'), {
      method: 'POST',
      body: JSON.stringify({ amount, currency })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return { url: data.url };
  },

  getUserCreditHistory: async (userId: string, currentUserId?: string): Promise<CreditHistoryEntry[]> => {
    // NEW: Backend API - Backend handles authorization automatically
    // If userId is current user, use /api/users/me/credit-history
    // If different user (admin only), use /api/users/:id/credit-history
    const endpoint = currentUserId === userId
      ? '/api/users/me/credit-history'
      : `/api/users/${userId}/credit-history`;

    const response = await authenticatedFetch(buildUrl(endpoint));

    if (!response.ok) {
      await handleApiError(response);
    }

    const result = await response.json();
    return result.creditHistory || [];
  },

  // OLD MOCKDB - KEPT FOR ROLLBACK
  // getUserCreditHistory: async (userId: string, currentUserId?: string) => apiCall(() => {
  //     // Authorization: Only allow if requesting own history or is admin
  //     if (currentUserId && currentUserId !== userId) {
  //         const users = db.get<User[]>('users', INITIAL_USERS);
  //         const currentUser = users.find(u => u.id === currentUserId);
  //         if (!currentUser || currentUser.role !== UserRole.ADMIN) {
  //             throw new Error("Unauthorized: You can only view your own credit history");
  //         }
  //     }
  //
  //     return db.get<CreditHistoryEntry[]>('creditHistory', INITIAL_CREDIT_HISTORY).filter(h => h.userId === userId);
  // }),

  //   updateUserCredit: async (userId: string, type: 'add' | 'subtract' | 'set', amount: number, note: string) => apiCall(() => {
  //       const users = db.get<User[]>('users', INITIAL_USERS);
  //       const idx = users.findIndex(u => u.id === userId);
  //       if (idx === -1) throw new Error("User not found");
  // 
  //       // ‚úÖ FIX BUG #6: Validate amount is not negative
  //       if (amount < 0) {
  //           throw new Error("Amount cannot be negative. Use appropriate operation type instead.");
  //       }
  // 
  //       // ‚úÖ FIX BUG #6: Validate final balance won't be negative for subtract/set operations
  //       if (type === 'add') {
  //           users[idx].credits += amount;
  //       } else if (type === 'subtract') {
  //           if (users[idx].credits < amount) {
  //               throw new Error(`Cannot subtract ${amount} credits. User only has ${users[idx].credits} credits.`);
  //           }
  //           users[idx].credits -= amount;
  //       } else {
  //           // type === 'set'
  //           if (amount < 0) {
  //               throw new Error("Cannot set credits to negative value");
  //           }
  //           users[idx].credits = amount;
  //       }
  // 
  //       db.set('users', users);
  // 
  //       const history = db.get<CreditHistoryEntry[]>('creditHistory', INITIAL_CREDIT_HISTORY);
  //       history.unshift({
  //           id: `ch_adj_${Date.now()}`,
  //           userId,
  //           type: 'admin_adjustment',
  //           amount: type === 'subtract' ? -amount : amount,
  //           balanceAfter: users[idx].credits,
  //           note: note,
  //           timestamp: new Date().toISOString()
  //       });
  //       db.set('creditHistory', history);
  //   }),

  // NEW BACKEND API CODE - Update user credits (admin only)
  updateUserCredit: async (userId: string, type: 'add' | 'subtract' | 'set', amount: number, note: string): Promise<User> => {
    const response = await authenticatedFetch(buildUrl(`/api/users/${userId}/adjust-credits`), {
      method: 'PATCH',
      body: JSON.stringify({ type, amount, note })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.user;
  },

  // --- BOOKING ---
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // createOneTimeBooking: async (menteeId: string, mentorId: string, startTime: string, duration: number, cost: number, useSubscription: boolean = false): Promise<Booking> => {
  //     return apiCall(async () => {

  // NEW BACKEND API CODE
  createOneTimeBooking: async (menteeId: string, mentorId: string, startTime: string, duration: number, cost: number, useSubscription: boolean = false): Promise<Booking> => {
    const response = await authenticatedFetch(buildUrl('/api/bookings'), {
      method: 'POST',
      body: JSON.stringify({
        mentorId,
        startTime,
        duration,
        cost,
        useSubscription
      })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.booking;
  },

  // OLD MOCKDB CODE CONTINUES - KEPT FOR ROLLBACK
  //       const users = db.get<User[]>('users', INITIAL_USERS);
  //       const mentee = users.find(u => u.id === menteeId);
  //       if (!mentee) throw new Error("Mentee not found");
  //       if (!useSubscription && mentee.credits < cost) throw new Error("S·ªë d∆∞ Credits kh√¥ng ƒë·ªß.");

  //           // ‚úÖ FIX BUG #4: Check mentor availability before booking
  //           const mentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
  //           const mentor = mentors.find(m => m.id === mentorId);
  //           if (!mentor) throw new Error("Mentor not found");
  // 
  //           // ‚úÖ FIX BUG #26: Check mentor status is ACTIVE before allowing bookings
  //           if (mentor.status !== 'ACTIVE') {
  //               throw new Error(`Cannot book with this mentor. Mentor status: ${mentor.status}`);
  //           }
  // 
  //           const endTime = new Date(new Date(startTime).getTime() + 60 * 60000).toISOString();
  //           const bookingStart = new Date(startTime);
  //           const bookingEnd = new Date(endTime);
  // 
  //           // ‚úÖ FIX BUG: Removed broken availability validation
  //           // UI already prevents bookings outside available slots via generateEvents()
  //           // The old logic was comparing Date objects incorrectly (slot.startTime is "14:00" string, not full date)
  //           // Keeping only double-booking check below which works correctly
  // 
  //           // Check for double booking
  //           const bookings = db.get<Booking[]>('bookings', INITIAL_BOOKINGS);
  //           const hasConflict = bookings.some(b =>
  //               b.mentorId === mentorId &&
  //               b.status === BookingStatus.SCHEDULED &&
  //               (
  //                   (bookingStart >= new Date(b.startTime) && bookingStart < new Date(b.endTime)) ||
  //                   (bookingEnd > new Date(b.startTime) && bookingEnd <= new Date(b.endTime)) ||
  //                   (bookingStart <= new Date(b.startTime) && bookingEnd >= new Date(b.endTime))
  //               )
  //           );
  // 
  //           if (hasConflict) {
  //               throw new Error("Mentor ƒë√£ c√≥ booking kh√°c t·∫°i th·ªùi ƒëi·ªÉm n√†y. Vui l√≤ng ch·ªçn th·ªùi gian kh√°c.");
  //           }
  // 
  //           const bookingId = `b_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`; // ‚úÖ Better unique ID
  // 
  //           // ‚úÖ FIX BUG #5: Deduct subscription session quota if using subscription
  //           let subscriptionId: string | undefined = undefined; // ‚úÖ FIX BUG #2: Track subscription ID
  //           if (useSubscription) {
  //               const subs = db.get<Subscription[]>('subscriptions', []);
  //               const activeSub = subs.find(s =>
  //                   s.menteeId === menteeId &&
  //                   s.mentorId === mentorId &&
  //                   s.status === 'ACTIVE' &&
  //                   s.remainingSessions > 0
  //               );
  // 
  //               if (!activeSub) {
  //                   throw new Error("Kh√¥ng t√¨m th·∫•y subscription c√≤n h·∫°n. Vui l√≤ng mua subscription ho·∫∑c d√πng credits.");
  //               }
  // 
  //               // ‚úÖ FIX BUG #2: Store subscription ID for tracking
  //               subscriptionId = activeSub.id;
  // 
  //               // Deduct session count
  //               activeSub.remainingSessions -= 1;
  //               if (!activeSub.bookings) activeSub.bookings = [];
  //               activeSub.bookings.push(bookingId);
  // 
  //               // Update subscription status if no sessions left
  //               if (activeSub.remainingSessions === 0) {
  //                   activeSub.status = 'EXPIRED';
  //               }
  // 
  //               db.set('subscriptions', subs);
  //           } else {
  //               // Hold credits for non-subscription booking
  //               await creditPendingServiceV2.holdCreditOnBooking(bookingId, menteeId, cost);
  //           }
  // 
  //           const newBooking: Booking = {
  //               id: bookingId, menteeId, mentorId,
  //               mentorName: mentor.name || 'Mentor',
  //               menteeName: mentee.name,
  //               startTime, endTime,
  //               status: BookingStatus.SCHEDULED,
  //               creditStatus: useSubscription ? 'released' : 'pending',
  //               type: useSubscription ? 'subscription' : 'credit',
  //               subscriptionId, // ‚úÖ FIX BUG #2: Include subscription ID in booking
  //               totalCost: cost,
  //               joinLink: 'https://meet.google.com/demo-call'
  //           };
  // 
  //           console.log('üíæ [API] Saving booking to localStorage...');
  //           console.log('  Current bookings count:', bookings.length);
  //           console.log('  New booking:', newBooking);
  // 
  //           bookings.push(newBooking);
  //           db.set('bookings', bookings);
  // 
  //           console.log('‚úÖ Booking saved. Total bookings now:', bookings.length);
  // 
  //           // Use notificationService for i18n support
  //           await notificationService.notifyNewBooking(mentorId, mentee.name, startTime, bookingId);
  // 
  //           return newBooking;
  //       });
  //   },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getBookingById: async (id: string, currentUserId?: string) => apiCall(() => {
  //     const booking = db.get<Booking[]>('bookings', INITIAL_BOOKINGS).find(b => b.id === id);
  //     // Authorization: Allow if user is mentee, mentor, or admin
  //     if (currentUserId && booking) {
  //         const users = db.get<User[]>('users', INITIAL_USERS);
  //         const currentUser = users.find(u => u.id === currentUserId);
  //         const isParticipant = booking.menteeId === currentUserId || booking.mentorId === currentUserId;
  //         const isAdmin = currentUser?.role === UserRole.ADMIN;
  //         if (!isParticipant && !isAdmin) {
  //             throw new Error("Unauthorized: You can only view your own bookings");
  //         }
  //     }
  //     return booking;
  // }),

  // NEW BACKEND API CODE
  getBookingById: async (id: string, currentUserId?: string): Promise<Booking | undefined> => {
    const response = await authenticatedFetch(buildUrl(`/api/bookings/${id}`));

    if (!response.ok) {
      if (response.status === 404 || response.status === 403) {
        return undefined;
      }
      await handleApiError(response);
    }

    const data = await response.json();
    return data.booking;
  },

  updateBookingStatus: async (id: string, status: BookingStatus) => apiCall(async () => {
      const bookings = db.get<Booking[]>('bookings', INITIAL_BOOKINGS);
      const idx = bookings.findIndex(b => b.id === id);
      if (idx === -1) return;

      const booking = bookings[idx];
      const currentStatus = booking.status;

      // ‚úÖ FIX BUG #3: Validate status transitions
      const ALLOWED_TRANSITIONS: Record<BookingStatus, BookingStatus[]> = {
          [BookingStatus.SCHEDULED]: [BookingStatus.COMPLETED, BookingStatus.CANCELLED, BookingStatus.NO_SHOW, BookingStatus.RESCHEDULED, BookingStatus.DISPUTED],
          [BookingStatus.COMPLETED]: [BookingStatus.DISPUTED],
          [BookingStatus.CANCELLED]: [], // Final state
          [BookingStatus.NO_SHOW]: [BookingStatus.DISPUTED],
          [BookingStatus.RESCHEDULED]: [BookingStatus.COMPLETED, BookingStatus.CANCELLED, BookingStatus.NO_SHOW, BookingStatus.DISPUTED],
          [BookingStatus.DISPUTED]: [BookingStatus.COMPLETED, BookingStatus.REFUNDED],
          [BookingStatus.REFUNDED]: [] // Final state
      };

      const allowedTransitions = ALLOWED_TRANSITIONS[currentStatus] || [];
      if (!allowedTransitions.includes(status)) {
          throw new Error(`Invalid status transition: ${currentStatus} ‚Üí ${status}. Allowed: ${allowedTransitions.join(', ')}`);
      }

      // Handle credit operations based on new status
      if (status === BookingStatus.COMPLETED && booking.type === 'credit' && booking.creditStatus === 'pending') {
          await creditPendingServiceV2.releaseCreditToMentor(id);
          booking.creditStatus = 'released';
      } else if ((status === BookingStatus.CANCELLED || status === BookingStatus.NO_SHOW) && booking.type === 'credit' && booking.creditStatus === 'pending') {
          await creditPendingServiceV2.refundCreditToMentee(id);
          booking.creditStatus = 'refunded';
      } else if ((status === BookingStatus.CANCELLED || status === BookingStatus.NO_SHOW) && booking.type === 'subscription') {
          // ‚úÖ FIX BUG #3: Restore subscription session with end date validation
          const subs = db.get<Subscription[]>('subscriptions', []);
          const sub = subs.find(s => s.bookings?.includes(id));
          if (sub) {
              // Restore session count
              sub.remainingSessions += 1;

              // ‚úÖ FIX BUG #3: Only reactivate if subscription hasn't expired by end date
              const now = new Date();
              const endDate = new Date(sub.endDate);

              if (sub.status === 'EXPIRED' && sub.remainingSessions > 0 && endDate > now) {
                  sub.status = 'ACTIVE'; // Only reactivate if still within subscription period
              }
              // If endDate has passed, keep status as EXPIRED even if sessions > 0

              sub.bookings = sub.bookings?.filter(b => b !== id) || [];
              db.set('subscriptions', subs);
          }
      }

      booking.status = status;
      db.set('bookings', bookings);
  }),

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // cancelBooking: async (id: string) => api.updateBookingStatus(id, BookingStatus.CANCELLED),

  // NEW BACKEND API CODE
  cancelBooking: async (id: string): Promise<Booking> => {
    const response = await authenticatedFetch(buildUrl(`/api/bookings/${id}/cancel`), {
      method: 'PATCH'
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.booking;
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // rescheduleBooking: async (id: string, newTime: string) => apiCall(() => {
  //     const bookings = db.get<Booking[]>('bookings', INITIAL_BOOKINGS);
  //     const idx = bookings.findIndex(b => b.id === id);
  //     if (idx === -1) throw new Error("Booking not found");
  //     bookings[idx].startTime = newTime;
  //     bookings[idx].endTime = new Date(new Date(newTime).getTime() + 60 * 60000).toISOString();
  //     bookings[idx].status = BookingStatus.RESCHEDULED;
  //     db.set('bookings', bookings);
  // }),

  // NEW BACKEND API CODE
  rescheduleBooking: async (id: string, newTime: string): Promise<Booking> => {
    const response = await authenticatedFetch(buildUrl(`/api/bookings/${id}/reschedule`), {
      method: 'PATCH',
      body: JSON.stringify({ newStartTime: newTime })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.booking;
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // submitReview: async (id: string, rating: number, review: string) => apiCall(() => {
  //     const bookings = db.get<Booking[]>('bookings', INITIAL_BOOKINGS);
  //     const idx = bookings.findIndex(b => b.id === id);
  //     if (idx !== -1) {
  //         bookings[idx].rating = rating;
  //         bookings[idx].review = review;
  //         db.set('bookings', bookings);
  //     }
  // }),

  // NEW BACKEND API CODE
  submitReview: async (id: string, rating: number, review: string): Promise<Booking> => {
    const response = await authenticatedFetch(buildUrl(`/api/bookings/${id}/review`), {
      method: 'POST',
      body: JSON.stringify({ rating, review })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.booking;
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // reportDispute: async (id: string, reason: string, evidence: string) => apiCall(() => {
  //     const bookings = db.get<Booking[]>('bookings', INITIAL_BOOKINGS);
  //     const idx = bookings.findIndex(b => b.id === id);
  //     if (idx === -1) throw new Error("Booking not found");
  //     bookings[idx].status = BookingStatus.DISPUTED;
  //     bookings[idx].disputeReason = reason;
  //     bookings[idx].disputeEvidence = evidence;
  //     bookings[idx].disputeDate = new Date().toISOString();
  //     db.set('bookings', bookings);
  // }),

  // NEW BACKEND API CODE
  reportDispute: async (id: string, reason: string, evidence: string): Promise<Booking> => {
    const response = await authenticatedFetch(buildUrl(`/api/bookings/${id}/dispute`), {
      method: 'POST',
      body: JSON.stringify({ reason, evidence })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.booking;
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // resolveDispute: async (id: string, outcome: 'REFUND_MENTEE' | 'DISMISS', note: string) => apiCall(async () => {
  //     const bookings = db.get<Booking[]>('bookings', INITIAL_BOOKINGS);
  //     const idx = bookings.findIndex(b => b.id === id);
  //     if (idx === -1) throw new Error("Booking not found");
  //     const booking = bookings[idx];
  //     if (outcome === 'REFUND_MENTEE') {
  //         if (booking.creditStatus === 'released') {
  //             throw new Error('Kh√¥ng th·ªÉ ho√†n ti·ªÅn - Credits ƒë√£ ƒë∆∞·ª£c chuy·ªÉn cho mentor. Vui l√≤ng x·ª≠ l√Ω th·ªß c√¥ng.');
  //         }
  //         if (booking.type === 'credit' && booking.creditStatus === 'pending') {
  //             await creditPendingServiceV2.refundCreditToMentee(id);
  //             booking.creditStatus = 'refunded';
  //         }
  //         booking.status = BookingStatus.REFUNDED;
  //     } else {
  //         if (booking.type === 'credit' && booking.creditStatus === 'pending') {
  //             await creditPendingServiceV2.releaseCreditToMentor(id);
  //             booking.creditStatus = 'released';
  //         }
  //         booking.status = BookingStatus.COMPLETED;
  //     }
  //     booking.resolutionNote = note;
  //     booking.resolvedAt = new Date().toISOString();
  //     db.set('bookings', bookings);
  // }),

  // NEW BACKEND API CODE
  resolveDispute: async (id: string, outcome: 'REFUND_MENTEE' | 'DISMISS', note: string): Promise<Booking> => {
    const response = await authenticatedFetch(buildUrl(`/api/bookings/${id}/resolve-dispute`), {
      method: 'PATCH',
      body: JSON.stringify({ outcome, note })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.booking;
  },

  // NEW BACKEND API CODE - Complete booking (releases credits to mentor)
  completeBooking: async (id: string): Promise<Booking> => {
    const response = await authenticatedFetch(buildUrl(`/api/bookings/${id}/complete`), {
      method: 'PATCH'
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.booking;
  },

  // --- HOMEWORK ---
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getHomework: async (userId: string, role: UserRole) => apiCall(() =>
  //   db.get<Homework[]>('homework', INITIAL_HOMEWORK).filter(h => role === UserRole.MENTEE ? h.menteeId === userId : h.mentorId === userId)
  // ),
  // getAllHomework: async () => apiCall(() => db.get<Homework[]>('homework', INITIAL_HOMEWORK)),
  // updateHomework: async (id: string, updates: Partial<Homework>) => apiCall(() => {
  //     const homeworks = db.get<Homework[]>('homework', INITIAL_HOMEWORK);
  //     const idx = homeworks.findIndex(h => h.id === id);
  //     if (idx !== -1) {
  //         homeworks[idx] = { ...homeworks[idx], ...updates };
  //         db.set('homework', homeworks);
  //     }
  // }),

  // NEW BACKEND API CODE
  getHomework: async (userId: string, role: UserRole): Promise<Homework[]> => {
    const response = await authenticatedFetch(buildUrl('/api/homework/my'));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getAllHomework: async (): Promise<Homework[]> => {
    const response = await authenticatedFetch(buildUrl('/api/homework/admin/all'));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getHomeworkById: async (id: string): Promise<Homework> => {
    const response = await authenticatedFetch(buildUrl(`/api/homework/${id}`));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  createHomework: async (bookingId: string, title: string, description: string, dueDate: string): Promise<Homework> => {
    const response = await authenticatedFetch(buildUrl('/api/homework'), {
      method: 'POST',
      body: JSON.stringify({ bookingId, title, description, dueDate })
    });
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  submitHomework: async (id: string, submissionUrl: string, submissionNote?: string): Promise<Homework> => {
    const response = await authenticatedFetch(buildUrl(`/api/homework/${id}/submit`), {
      method: 'POST',
      body: JSON.stringify({ submissionUrl, submissionNote })
    });
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  gradeHomework: async (id: string, grade: number, feedback: string): Promise<Homework> => {
    const response = await authenticatedFetch(buildUrl(`/api/homework/${id}/grade`), {
      method: 'POST',
      body: JSON.stringify({ grade, feedback })
    });
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  updateHomework: async (id: string, updates: Partial<Homework>): Promise<Homework> => {
    const response = await authenticatedFetch(buildUrl(`/api/homework/${id}`), {
      method: 'PATCH',
      body: JSON.stringify(updates)
    });
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  deleteHomework: async (id: string): Promise<void> => {
    const response = await authenticatedFetch(buildUrl(`/api/homework/${id}`), {
      method: 'DELETE'
    });
    if (!response.ok) await handleApiError(response);
  },

  getPendingHomework: async (): Promise<Homework[]> => {
    const response = await authenticatedFetch(buildUrl('/api/homework/pending'));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getOverdueHomework: async (): Promise<Homework[]> => {
    const response = await authenticatedFetch(buildUrl('/api/homework/overdue'));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getHomeworkStats: async (): Promise<any> => {
    const response = await authenticatedFetch(buildUrl('/api/homework/stats'));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  // --- MENTOR EARNINGS ---
  getMentorBalanceDetails: async (id: string) => apiCall(() => mentorPayoutServiceV2.getMentorBalanceDetails(id)),

  // --- PAYOUTS ---
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getPayouts: async (userId: string) => apiCall(() => db.get<Payout[]>('payouts', INITIAL_PAYOUTS).filter(p => p.mentorId === userId)),
  // getAllPayouts: async () => apiCall(() => db.get<Payout[]>('payouts', INITIAL_PAYOUTS)),
  // getPayoutById: async (id: string) => apiCall(() => db.get<Payout[]>('payouts', INITIAL_PAYOUTS).find(p => p.id === id)),

  // NEW BACKEND API CODE
  getPayouts: async (userId: string): Promise<Payout[]> => {
    const response = await authenticatedFetch(buildUrl('/api/payouts'));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data;
  },

  getAllPayouts: async (): Promise<Payout[]> => {
    const response = await authenticatedFetch(buildUrl('/api/payouts'));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data;
  },

  getPayoutById: async (id: string): Promise<Payout | undefined> => {
    const response = await authenticatedFetch(buildUrl(`/api/payouts/${id}`));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data;
  },
  
  requestPayout: async (currentUser: User | null, mentorId: string, amount: number, method: string) => apiCall(() => mentorPayoutServiceV2.requestPayout(currentUser, mentorId, amount, method)),
  
  approvePayout: async (currentUser: User | null, id: string, note?: string) => apiCall(() => mentorPayoutServiceV2.approvePayout(currentUser, id, note)),
  
  rejectPayout: async (currentUser: User | null, id: string, reason: string) => apiCall(() => mentorPayoutServiceV2.rejectPayout(currentUser, id, reason)),

  // NEW BACKEND API CODE - Mark payout as paid
  markPayoutPaid: async (id: string, evidenceFile: string): Promise<Payout> => {
    const response = await authenticatedFetch(buildUrl(`/api/payouts/${id}/mark-paid`), {
      method: 'PATCH',
      body: JSON.stringify({ evidenceFile })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data;
  },

  getSystemFinancialHealth: async (currentUser: User | null) => apiCall(() => mentorPayoutServiceV2.getSystemFinancialHealth(currentUser)),

  // --- TRANSACTIONS & PAYMENTS ---
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getAllTransactions: async () => apiCall(() => db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS)),
  // getTransactionById: async (id: string, currentUserId?: string) => apiCall(() => {
  //     const transaction = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS).find(t => t.id === id);
  //     // Authorization: Only allow if user owns the transaction or is admin
  //     if (currentUserId && transaction) {
  //         const users = db.get<User[]>('users', INITIAL_USERS);
  //         const currentUser = users.find(u => u.id === currentUserId);
  //         const isOwner = transaction.userId === currentUserId;
  //         const isAdmin = currentUser?.role === UserRole.ADMIN;
  //         if (!isOwner && !isAdmin) {
  //             throw new Error("Unauthorized: You can only view your own transactions");
  //         }
  //     }
  //     return transaction;
  // }),
  // createMockTransaction: async (data: any) => apiCall(() => {
  //     const txs = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS);
  //     const newTx = { ...data, id: `tx_${Date.now()}` };
  //     txs.push(newTx);
  //     db.set('transactions', txs);
  //     return newTx;
  // }),
  // completePayment: async (txId: string, evidence: string, note: string) => apiCall(async () => {
  //     const txs = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS);
  //     const txIdx = txs.findIndex(t => t.id === txId);
  //     if (txIdx === -1) throw new Error("Transaction not found");
  //     // ‚úÖ FIX BUG #14: Validate payout status before marking as paid
  //     if (txs[txIdx].payoutId) {
  //         const payouts = db.get<Payout[]>('payouts', INITIAL_PAYOUTS);
  //         const payout = payouts.find(p => p.id === txs[txIdx].payoutId);
  //         if (!payout) {
  //             throw new Error("Associated payout not found");
  //         }
  //         if (payout.status !== 'APPROVED_PENDING_PAYMENT') {
  //             throw new Error(`Cannot mark payout as paid. Current status: ${payout.status}. Payout must be APPROVED_PENDING_PAYMENT first.`);
  //         }
  //         await mentorPayoutServiceV2.markPayoutPaid(null, txs[txIdx].payoutId!, evidence);
  //     }
  //     txs[txIdx].status = 'success';
  //     txs[txIdx].evidenceFile = evidence;
  //     txs[txIdx].reason = note;
  //     db.set('transactions', txs);
  // }),
  // failPayment: async (txId: string, reason: string) => apiCall(() => {
  //     const txs = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS);
  //     const txIdx = txs.findIndex(t => t.id === txId);
  //     if (txIdx !== -1) {
  //         txs[txIdx].status = 'failed';
  //         txs[txIdx].reason = reason;
  //         db.set('transactions', txs);
  //     }
  // }),

  // NEW BACKEND API CODE
  // Get all transactions (admin only) - uses topup admin endpoint
  getAllTransactions: async (): Promise<Transaction[]> => {
    const response = await authenticatedFetch(buildUrl('/api/topup/admin/all'));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data;
  },

  // Get transaction by ID - backend handles authorization
  getTransactionById: async (id: string, currentUserId?: string): Promise<Transaction | undefined> => {
    const response = await authenticatedFetch(buildUrl(`/api/topup/transaction/${id}`));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data;
  },

  // REMOVED: createMockTransaction - Backend handles transaction creation via topup/booking
  // REMOVED: completePayment - Handled by Stripe webhook
  // REMOVED: failPayment - Handled by Stripe webhook

  // --- PROVIDERS ---
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getProviders: async () => apiCall(() => db.get<Provider[]>('providers', INITIAL_PROVIDERS)),
  // getProviderProfile: async (id: string) => apiCall(() => db.get<Provider[]>('providers', INITIAL_PROVIDERS).find(p => p.id === id)),
  // getReferrals: async (pid: string) => apiCall(() => db.get<Referral[]>('referrals', INITIAL_REFERRALS).filter(r => r.providerId === pid)),
  // getProviderCommissions: async (pid: string) => apiCall(() => db.get<ProviderCommission[]>('providerCommissions', INITIAL_COMMISSIONS).filter(c => c.providerId === pid)),
  // getProviderLevels: async () => apiCall(() => db.get<ProviderLevel[]>('providerLevels', INITIAL_PROVIDER_LEVELS)),
  // updateProviderProfile: async (id: string, data: any) => api.updateUserProfile(id, data),
  // updateProviderLevel, addProviderLevel, deleteProviderLevel

  // NEW BACKEND API CODE - Provider functions
  getProviders: async (): Promise<Provider[]> => {
    const response = await fetch(buildUrl('/api/providers'));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getProviderProfile: async (id: string): Promise<Provider> => {
    const response = await fetch(buildUrl(`/api/providers/${id}`));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  updateProviderProfile: async (id: string, data: any): Promise<any> => {
    const response = await authenticatedFetch(buildUrl(`/api/providers/${id}/profile`), {
      method: 'PATCH',
      body: JSON.stringify(data)
    });
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getReferrals: async (pid: string): Promise<Referral[]> => {
    const response = await authenticatedFetch(buildUrl(`/api/providers/${pid}/referrals`));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  createReferral: async (menteeId: string, menteeName: string): Promise<Referral> => {
    const response = await authenticatedFetch(buildUrl('/api/providers/referrals'), {
      method: 'POST',
      body: JSON.stringify({ menteeId, menteeName })
    });
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getProviderCommissions: async (pid: string, status?: string): Promise<ProviderCommission[]> => {
    const url = status ? `/api/providers/${pid}/commissions?status=${status}` : `/api/providers/${pid}/commissions`;
    const response = await authenticatedFetch(buildUrl(url));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getProviderCommissionStats: async (pid: string): Promise<any> => {
    const response = await authenticatedFetch(buildUrl(`/api/providers/${pid}/commission-stats`));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  markCommissionPaid: async (commissionId: string): Promise<ProviderCommission> => {
    const response = await authenticatedFetch(buildUrl(`/api/providers/admin/commissions/${commissionId}/mark-paid`), {
      method: 'PATCH'
    });
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getAllReferrals: async (): Promise<Referral[]> => {
    const response = await authenticatedFetch(buildUrl('/api/providers/admin/referrals'));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getAllCommissions: async (status?: string): Promise<ProviderCommission[]> => {
    const url = status ? `/api/providers/admin/commissions?status=${status}` : '/api/providers/admin/commissions';
    const response = await authenticatedFetch(buildUrl(url));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  // ProviderLevel functions - backend doesn't have these endpoints yet, return empty/stub
  getProviderLevels: async (): Promise<ProviderLevel[]> => {
    console.warn('getProviderLevels: Backend endpoint not implemented');
    return [];
  },

  updateProviderLevel: async (id: string, data: any): Promise<void> => {
    console.warn('updateProviderLevel: Backend endpoint not implemented');
  },

  addProviderLevel: async (data: any): Promise<void> => {
    console.warn('addProviderLevel: Backend endpoint not implemented');
  },

  deleteProviderLevel: async (id: string): Promise<void> => {
    console.warn('deleteProviderLevel: Backend endpoint not implemented');
  },

  // --- SUBSCRIPTIONS ---
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getSubscriptionPlans: async () => apiCall(() => db.get<SubscriptionPlan[]>('subscriptionPlans', SUBSCRIPTION_PLANS)),

  // NEW BACKEND API CODE
  getSubscriptionPlans: async (): Promise<SubscriptionPlan[]> => {
    const response = await fetch(buildUrl('/api/subscriptions/plans'));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.plans || [];
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // createSubscription: async (userId: string, planId: string, mentorId: string, slots: any[]) => apiCall(() => {
  //     const plans = db.get<SubscriptionPlan[]>('subscriptionPlans', SUBSCRIPTION_PLANS);
  //     const plan = plans.find(p => p.id === planId);
  //     if (!plan) throw new Error("Plan not found");
  //     const subs = db.get<Subscription[]>('subscriptions', []);
  //     const mentor = db.get<Mentor[]>('mentors', INITIAL_MENTORS).find(m => m.id === mentorId);
  //     const newSub: Subscription = {
  //         id: `sub_${Date.now()}`,
  //         planId,
  //         planName: plan.name,
  //         menteeId: userId,
  //         mentorId,
  //         mentorName: mentor?.name || 'Mentor',
  //         startDate: new Date().toISOString(),
  //         endDate: new Date(Date.now() + plan.durationWeeks * 7 * 86400000).toISOString(),
  //         totalSessions: plan.sessions,
  //         remainingSessions: plan.sessions,
  //         cancelQuota: plan.allowedCancel,
  //         rescheduleQuota: plan.allowedReschedule,
  //         status: 'ACTIVE',
  //         bookings: []
  //     };
  //     subs.push(newSub);
  //     db.set('subscriptions', subs);
  //     return newSub;
  // }),

  // NEW BACKEND API CODE
  createSubscription: async (userId: string, planId: string, mentorId: string, slots: any[]): Promise<Subscription> => {
    const response = await authenticatedFetch(buildUrl('/api/subscriptions'), {
      method: 'POST',
      body: JSON.stringify({ planId, mentorId })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.subscription;
  },

  // NEW BACKEND API CODE - Cancel subscription
  cancelSubscription: async (id: string): Promise<Subscription> => {
    const response = await authenticatedFetch(buildUrl(`/api/subscriptions/${id}/cancel`), {
      method: 'PATCH'
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.subscription;
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  //   resetSubscriptionQuota: async (id: string) => apiCall(() => {
  //       const subs = db.get<Subscription[]>('subscriptions', []);
  //       const sIdx = subs.findIndex(s => s.id === id);
  //       if (sIdx !== -1) {
  //           const plan = SUBSCRIPTION_PLANS.find(p => p.id === subs[sIdx].planId);
  //           if (plan) {
  //               subs[sIdx].cancelQuota = plan.allowedCancel;
  //               subs[sIdx].rescheduleQuota = plan.allowedReschedule;
  //               db.set('subscriptions', subs);
  //           }
  //       }
  //   }),

  //   forceRenewSubscription: async (id: string) => apiCall(async () => {
  //       const subs = db.get<Subscription[]>('subscriptions', []);
  //       const sIdx = subs.findIndex(s => s.id === id);
  //       if (sIdx === -1) throw new Error("Subscription not found");
  // 
  //       const s = subs[sIdx];
  //       const plan = SUBSCRIPTION_PLANS.find(p => p.id === s.planId);
  //       if (!plan) throw new Error("Plan not found");
  // 
  //       // ‚úÖ FIX BUG #13: Check balance and charge credits before renewing
  //       const users = db.get<User[]>('users', INITIAL_USERS);
  //       const mentee = users.find(u => u.id === s.menteeId);
  //       if (!mentee) throw new Error("Mentee not found");
  // 
  //       const planPrice = plan.price; // Use full price for renewal
  // 
  //       if (Number(mentee.credits) < Number(planPrice)) {
  //           throw new Error(`Insufficient credits for renewal. Need ${Number(planPrice).toFixed(0)} credits, have ${Number(mentee.credits).toFixed(0)} credits.`);
  //       }
  // 
  //       // Deduct credits
  //       const menteeIdx = users.findIndex(u => u.id === s.menteeId);
  //       users[menteeIdx].credits -= planPrice;
  //       db.set('users', users);
  // 
  //       // Record transaction
  //       const txs = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS);
  //       txs.push({
  //           id: `tx_sub_renew_${Date.now()}`,
  //           userId: s.menteeId,
  //           type: 'SUBSCRIPTION_RENEWAL',
  //           amount: -planPrice,
  //           description: `Subscription renewal: ${plan.name}`,
  //           date: new Date().toISOString(),
  //           status: 'COMPLETED',
  //           method: 'Credits',
  //           relatedEntityId: id
  //       });
  //       db.set('transactions', txs);
  // 
  //       // Record credit history
  //       const history = db.get<CreditHistoryEntry[]>('creditHistory', INITIAL_CREDIT_HISTORY);
  //       history.unshift({
  //           id: `ch_sub_renew_${Date.now()}`,
  //           userId: s.menteeId,
  //           type: 'subscription_renewal',
  //           amount: -planPrice,
  //           balanceAfter: users[menteeIdx].credits,
  //           note: `Subscription renewal: ${plan.name}`,
  //           timestamp: new Date().toISOString()
  //       });
  //       db.set('creditHistory', history);
  // 
  //       // Renew subscription
  //       s.endDate = new Date(new Date(s.endDate).getTime() + plan.durationWeeks * 7 * 86400000).toISOString();
  //       s.remainingSessions = plan.sessions;
  //       s.cancelQuota = plan.allowedCancel;
  //       s.rescheduleQuota = plan.allowedReschedule;
  //       s.status = 'ACTIVE';
  //       db.set('subscriptions', subs);
  //   }),

  //   changeSubscriptionPlan: async (id: string, planId: string) => apiCall(() => {
  //       const subs = db.get<Subscription[]>('subscriptions', []);
  //       const sIdx = subs.findIndex(s => s.id === id);
  //       if (sIdx !== -1) {
  //           const plan = SUBSCRIPTION_PLANS.find(p => p.id === planId);
  //           if (!plan) throw new Error("Plan not found");
  //           subs[sIdx].planId = planId;
  //           subs[sIdx].planName = plan.name;
  //           db.set('subscriptions', subs);
  //       }
  //   }),

  // NEW BACKEND API CODE - Reset subscription quota (admin)
  resetSubscriptionQuota: async (id: string): Promise<Subscription> => {
    const response = await authenticatedFetch(buildUrl(`/api/subscriptions/admin/${id}/reset-quota`), {
      method: 'PATCH'
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.subscription;
  },

  // NEW BACKEND API CODE - Force renew subscription (admin)
  forceRenewSubscription: async (id: string): Promise<Subscription> => {
    const response = await authenticatedFetch(buildUrl(`/api/subscriptions/${id}/renew`), {
      method: 'PATCH'
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.subscription;
  },

  // NEW BACKEND API CODE - Change subscription plan (admin)
  changeSubscriptionPlan: async (id: string, planId: string): Promise<Subscription> => {
    const response = await authenticatedFetch(buildUrl(`/api/subscriptions/admin/${id}/change-plan`), {
      method: 'PATCH',
      body: JSON.stringify({ planId })
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.subscription;
  },

  updateSubscriptionPlan: async (id: string, data: any) => apiCall(() => {
      const plans = db.get<SubscriptionPlan[]>('subscriptionPlans', SUBSCRIPTION_PLANS);
      const idx = plans.findIndex(p => p.id === id);
      if (idx !== -1) { plans[idx] = { ...plans[idx], ...data }; db.set('subscriptionPlans', plans); }
  }),
  addSubscriptionPlan: async (data: any) => apiCall(() => {
      const plans = db.get<SubscriptionPlan[]>('subscriptionPlans', SUBSCRIPTION_PLANS);
      plans.push(data); db.set('subscriptionPlans', plans);
  }),
  deleteSubscriptionPlan: async (id: string) => apiCall(() => {
      const plans = db.get<SubscriptionPlan[]>('subscriptionPlans', SUBSCRIPTION_PLANS);
      db.set('subscriptionPlans', plans.filter(p => p.id !== id));
  }),

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getMentorSubscriptions: async (mid: string) => apiCall(() => db.get<Subscription[]>('subscriptions', []).filter(s => s.mentorId === mid)),

  // NEW BACKEND API CODE
  getMentorSubscriptions: async (mid: string): Promise<Subscription[]> => {
    const response = await authenticatedFetch(buildUrl('/api/subscriptions/mentor/my'));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.subscriptions || [];
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getUserSubscriptions: async (uid: string) => apiCall(() => db.get<Subscription[]>('subscriptions', []).filter(s => s.menteeId === uid)),

  // NEW BACKEND API CODE
  getUserSubscriptions: async (uid: string): Promise<Subscription[]> => {
    const response = await authenticatedFetch(buildUrl('/api/subscriptions/my'));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.subscriptions || [];
  },

  // --- USER MGMT & CONFIG ---
  getUserById: async (id: string): Promise<User | undefined> => {
    // NEW: Backend API
    const response = await authenticatedFetch(buildUrl(`/api/users/${id}`));

    if (!response.ok) {
      await handleApiError(response);
    }

    const result = await response.json();
    return result.user;
  },

  // OLD MOCKDB - KEPT FOR ROLLBACK
  // getUserById: async (id: string) => apiCall(() => db.get<User[]>('users', INITIAL_USERS).find(u => u.id === id)),
  
  deleteUser: async (id: string) => apiCall(() => {
      // ‚úÖ FIX BUG #10: Cascade delete all related data
      const users = db.get<User[]>('users', INITIAL_USERS);
      db.set('users', users.filter(u => u.id !== id));

      // Delete from role-specific tables
      const mentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
      setStore('mentors', mentors.filter(m => m.id !== id));

      const providers = db.get<Provider[]>('providers', INITIAL_PROVIDERS);
      setStore('providers', providers.filter(p => p.id !== id));

      // Delete bookings
      const bookings = db.get<Booking[]>('bookings', INITIAL_BOOKINGS);
      setStore('bookings', bookings.filter(b => b.menteeId !== id && b.mentorId !== id));

      // Delete homework
      const homework = db.get<Homework[]>('homework', INITIAL_HOMEWORK);
      setStore('homework', homework.filter(h => h.booking?.menteeId !== id && h.booking?.mentorId !== id));

      // Delete conversations and messages
      const convs = db.get<Conversation[]>('conversations', INITIAL_CONVERSATIONS);
      const deletedConvIds = convs.filter(c => c.participantId === id).map(c => c.id);
      setStore('conversations', convs.filter(c => c.participantId !== id));

      const messages = db.get<Message[]>('messages', INITIAL_MESSAGES);
      setStore('messages', messages.filter(m => !deletedConvIds.includes(m.conversationId) && m.fromId !== id));

      // Delete notifications
      const notifications = db.get<Notification[]>('notifications', INITIAL_NOTIFICATIONS);
      setStore('notifications', notifications.filter(n => n.userId !== id));

      // Delete credit history
      const creditHistory = db.get<CreditHistoryEntry[]>('creditHistory', INITIAL_CREDIT_HISTORY);
      setStore('creditHistory', creditHistory.filter(c => c.userId !== id));

      // Delete transactions
      const transactions = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS);
      setStore('transactions', transactions.filter(t => t.userId !== id));

      // Delete payouts (if mentor)
      const payouts = db.get<Payout[]>('payouts', INITIAL_PAYOUTS);
      setStore('payouts', payouts.filter(p => p.mentorId !== id));

      // Delete subscriptions
      const subscriptions = db.get<Subscription[]>('subscriptions', []);
      setStore('subscriptions', subscriptions.filter(s => s.menteeId !== id && s.mentorId !== id));

      // Delete referrals and commissions (if provider)
      const referrals = db.get<Referral[]>('referrals', INITIAL_REFERRALS);
      setStore('referrals', referrals.filter(r => r.providerId !== id));

      const commissions = db.get<ProviderCommission[]>('providerCommissions', INITIAL_COMMISSIONS);
      setStore('commissions', commissions.filter(c => c.providerId !== id));

      // Delete mentor earnings
      const earnings = db.get<MentorEarning[]>('mentorEarnings', []);
      setStore('mentorEarnings', earnings.filter(e => e.mentorId !== id));

      // Delete system credit ledger entries
      const ledger = db.get<SystemCreditLedgerEntry[]>('systemCreditLedger', INITIAL_SYSTEM_CREDIT_LEDGER);
      setStore('systemCreditLedger', ledger.filter(l => l.fromUserId !== id && l.toUserId !== id && l.toUserId !== 'system'));
  }),

  updateUserStatus: async (id: string, status: any) => apiCall(() => {
      const users = db.get<User[]>('users', INITIAL_USERS);
      const idx = users.findIndex(u => u.id === id);
      if (idx !== -1) { 
          users[idx].status = status; 
          db.set('users', users); 

          // Logic s·ª≠a l·ªói: ƒê·ªìng b·ªô Status sang b·∫£ng Mentors/Providers
          if (users[idx].role === UserRole.MENTOR) {
              const mentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
              const mIdx = mentors.findIndex(m => m.id === id);
              if (mIdx !== -1) {
                  mentors[mIdx].status = status;
                  setStore('mentors', mentors);
              }
          }
          if (users[idx].role === UserRole.PROVIDER) {
              const providers = db.get<Provider[]>('providers', INITIAL_PROVIDERS);
              const pIdx = providers.findIndex(p => p.id === id);
              if (pIdx !== -1) {
                  providers[pIdx].status = status;
                  setStore('providers', providers);
              }
          }
      }
  }),

  updateUser: async (id: string, data: any): Promise<User | undefined> => {
    // NEW: Backend API - Use /api/users/me for current user
    const response = await authenticatedFetch(buildUrl('/api/users/me'), {
      method: 'PATCH',
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const result = await response.json();
    return result.user;
  },

  // OLD MOCKDB - KEPT FOR ROLLBACK
  // updateUser: async (id: string, data: any) => apiCall(() => {
  //     const users = db.get<User[]>('users', INITIAL_USERS);
  //     const idx = users.findIndex(u => u.id === id);
  //     if (idx !== -1) {
  //         // ‚úÖ FIX BUG #11: Validate and set timezone
  //         if (data.country && !data.timezone) {
  //             data.timezone = getTimezoneByCountry(data.country);
  //         } else if (data.timezone) {
  //             // Validate timezone if provided manually
  //             try {
  //                 data.timezone = validateTimezone(data.timezone, users[idx].country || 'US');
  //             } catch (error: any) {
  //                 throw new Error(error.message);
  //             }
  //         }
  //
  //         // Merge data into User table
  //         users[idx] = { ...users[idx], ...data };
  //         db.set('users', users);
  //
  //         const updatedUser = users[idx];
  //
  //         // Logic s·ª≠a l·ªói: ƒê·ªìng b·ªô to√†n b·ªô d·ªØ li·ªáu User sang b·∫£ng Mentors/Providers
  //         if (updatedUser.role === UserRole.MENTOR) {
  //             const mentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
  //             const mIdx = mentors.findIndex(m => m.id === id);
  //             if (mIdx !== -1) {
  //                 mentors[mIdx] = {
  //                     ...mentors[mIdx],
  //                     ...updatedUser,
  //                     ...data
  //                 };
  //                 setStore('mentors', mentors);
  //             }
  //         }
  //
  //         if (updatedUser.role === UserRole.PROVIDER) {
  //             const providers = db.get<Provider[]>('providers', INITIAL_PROVIDERS);
  //             const pIdx = providers.findIndex(p => p.id === id);
  //             if (pIdx !== -1) {
  //                 providers[pIdx] = {
  //                     ...providers[pIdx],
  //                     ...updatedUser,
  //                     ...data
  //                 };
  //                 setStore('providers', providers);
  //             }
  //         }
  //     }
  // }),

  updateUserProfile: async (id: string, data: any) => api.updateUser(id, data),
  updateUserConfig: async (id: string, data: any) => api.updateUser(id, data),

  createUser: async (data: any) => api.register(data),

  // ‚úÖ FIX BUG #5: Add authorization check for password reset
  resetPassword: async (userId: string, pass: string, currentUserId?: string) => apiCall(async () => {
      // Authorization: Only allow if:
      // 1. User is resetting their own password, OR
      // 2. User is an admin (for admin password reset functionality)
      if (currentUserId && currentUserId !== userId) {
          const currentUsers = db.get<User[]>('users', INITIAL_USERS);
          const currentUser = currentUsers.find(u => u.id === currentUserId);
          if (!currentUser || currentUser.role !== UserRole.ADMIN) {
              throw new Error("Unauthorized: Only admins can reset other users' passwords");
          }
      }

      const users = db.get<User[]>('users', INITIAL_USERS);
      const idx = users.findIndex(u => u.id === userId);
      if (idx === -1) throw new Error("User not found");

      // Hash the new password before storing
      users[idx].password = await security.hashPassword(pass);
      db.set('users', users);
  }),

  // --- ANALYTICS ---
  getWeeklyRevenue: async (): Promise<WeeklyRevenueResponse> => apiCall(() => {
      const txs = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS);
      const days = [];
      let totalTopup = 0, totalPayout = 0;
      for (let i = 6; i >= 0; i--) {
          const d = new Date(); d.setDate(d.getDate() - i);
          const dateStr = d.toISOString().split('T')[0];
          const dTx = txs.filter(t => t.date.startsWith(dateStr));
          const topup = dTx.filter(t => t.type === 'TOPUP').reduce((a,b) => a + b.amount, 0);
          const payout = dTx.filter(t => (t.type === 'PAYOUT' || t.type === 'mentor_payout' || t.type === 'provider_payout') && (t.status === 'COMPLETED' || t.status === 'success')).reduce((a,b) => a + Math.abs(b.amount), 0);
          days.push({ date: dateStr, topupVolume: topup, payoutVolume: payout });
          totalTopup += topup; totalPayout += payout;
      }
      return { week: "Current Week", days, totalTopup, totalPayout, net: totalTopup - totalPayout };
  }),

  getMonthlyRevenue: async (year: number, month: number): Promise<MonthlyRevenueResponse> => apiCall(() => {
      const txs = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS);
      const days = [];
      let totalTopup = 0, totalPayout = 0;
      const daysInMonth = new Date(year, month, 0).getDate();
      for (let i = 1; i <= daysInMonth; i++) {
          const dateStr = `${year}-${month.toString().padStart(2, '0')}-${i.toString().padStart(2, '0')}`;
          const dTx = txs.filter(t => t.date.startsWith(dateStr));
          const topup = dTx.filter(t => t.type === 'TOPUP').reduce((a,b) => a + b.amount, 0);
          const payout = dTx.filter(t => (t.type === 'PAYOUT' || t.type === 'mentor_payout' || t.type === 'provider_payout') && (t.status === 'COMPLETED' || t.status === 'success')).reduce((a,b) => a + Math.abs(b.amount), 0);
          days.push({ date: dateStr, topupVolume: topup, payoutVolume: payout });
          totalTopup += topup; totalPayout += payout;
      }
      return { month: `${year}-${month}`, days, totalTopup, totalPayout, net: totalTopup - totalPayout };
  }),

  getAdminCreditStats: async () => apiCall(() => {
      const ledger = db.get<SystemCreditLedgerEntry[]>('systemCreditLedger', INITIAL_SYSTEM_CREDIT_LEDGER);
      return {
          summary: {
              holding: ledger.filter(l => l.status === 'holding').reduce((a,b) => a + b.amount, 0),
              released: ledger.filter(l => l.status === 'released').reduce((a,b) => a + b.amount, 0),
              refunded: ledger.filter(l => l.status === 'returned').reduce((a,b) => a + b.amount, 0),
              pendingBookings: ledger.filter(l => l.status === 'holding').length
          },
          records: ledger
      };
  }),

  getAdminCACStats: async () => apiCall(() => {
      const txs = db.get<Transaction[]>('transactions', INITIAL_TRANSACTIONS);
      const comms = db.get<ProviderCommission[]>('providerCommissions', INITIAL_COMMISSIONS);
      const providers = db.get<Provider[]>('providers', INITIAL_PROVIDERS);
      const levels = db.get<ProviderLevel[]>('providerLevels', INITIAL_PROVIDER_LEVELS);
      const revenue = txs.filter(t => t.type === 'TOPUP').reduce((a,b) => a + b.amount, 0);
      const cac = comms.reduce((a,b) => a + b.commissionAmountUsd, 0);
      
      const byProvider = providers.map(p => {
          const pc = comms.filter(c => c.providerId === p.id);
          const rev = pc.reduce((a,b) => a + b.topupAmountUsd, 0);
          const cost = pc.reduce((a,b) => a + b.commissionAmountUsd, 0);
          return { providerId: p.id, providerName: p.name, levelId: p.levelId, revenueGenerated: rev, commissionCost: cost, cacRatio: rev > 0 ? cost / rev : 0 };
      });

      const byLevel = levels.map(l => {
          const lp = providers.filter(p => p.levelId === l.id);
          const lc = comms.filter(c => lp.some(p => p.id === c.providerId));
          const rev = lc.reduce((a,b) => a + b.topupAmountUsd, 0);
          const cost = lc.reduce((a,b) => a + b.commissionAmountUsd, 0);
          return { levelId: l.id, providerCount: lp.length, totalRevenue: rev, totalCAC: cost, cacRatio: rev > 0 ? cost / rev : 0 };
      });

      return { summary: { revenue, cac, cacRatio: revenue > 0 ? cac / revenue : 0, grossProfit: revenue - cac }, byProvider, byLevel, timeSeries: [] };
  }),

  // --- PRICING BATCH ---
  batchSavePricing: async (
    base: number,
    ratio: number,
    countries: any[],
    groups: any[],
    creditPackages?: number[],
    currencies?: any[]
  ) => apiCall(() => {
      // ‚úÖ FIX: GET existing settings first to preserve all fields
      const existingSettings = db.get<SystemSettings>('settings', INITIAL_SETTINGS);

      const settings: SystemSettings = {
        baseLessonCreditPrice: base,
        topupConversionRatio: ratio,
        creditPackages: creditPackages !== undefined ? creditPackages : existingSettings.creditPackages,
        currencies: currencies !== undefined ? currencies : existingSettings.currencies
      };

      db.set('settings', settings);
      setStore('pricingCountries', countries);
      setStore('pricingGroups', groups);
  }),

  updatePricingCountry: async (id: string, data: any) => apiCall(() => {
      const c = db.get<PricingCountry[]>('pricingCountries', INITIAL_PRICING_COUNTRIES);
      const idx = c.findIndex(x => x.id === id);
      if (idx !== -1) { c[idx] = data; setStore('pricingCountries', c); }
  }),
  addPricingCountry: async (data: any) => apiCall(() => {
      const c = db.get<PricingCountry[]>('pricingCountries', INITIAL_PRICING_COUNTRIES);
      c.push(data); setStore('pricingCountries', c);
  }),
  deletePricingCountry: async (id: string) => apiCall(() => {
      const c = db.get<PricingCountry[]>('pricingCountries', INITIAL_PRICING_COUNTRIES);
      setStore('pricingCountries', c.filter(x => x.id !== id));
  }),

  updatePricingGroup: async (id: string, data: any) => apiCall(() => {
      const g = db.get<PricingGroup[]>('pricingGroups', INITIAL_PRICING_GROUPS);
      const idx = g.findIndex(x => x.id === id);
      if (idx !== -1) { g[idx] = data; setStore('pricingGroups', g); }
  }),
  addPricingGroup: async (data: any) => apiCall(() => {
      const g = db.get<PricingGroup[]>('pricingGroups', INITIAL_PRICING_GROUPS);
      g.push(data); setStore('pricingGroups', g);
  }),
  deletePricingGroup: async (id: string) => apiCall(() => {
      const g = db.get<PricingGroup[]>('pricingGroups', INITIAL_PRICING_GROUPS);
      setStore('pricingGroups', g.filter(x => x.id !== id));
  }),

  // --- UTILS ---
  getUsers: async (): Promise<User[]> => {
    // NEW: Backend API - Admin only endpoint
    const response = await authenticatedFetch(buildUrl('/api/users/admin/all'));

    if (!response.ok) {
      await handleApiError(response);
    }

    const result = await response.json();
    return result.users || [];
  },

  // OLD MOCKDB - KEPT FOR ROLLBACK
  // getUsers: async () => apiCall(() => db.get('users', INITIAL_USERS)),

  // --- ADMIN APPROVAL APIs ---
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getPendingUsers: async () => apiCall(() => { ... }),
  // approveUser: async (userId: string) => apiCall(async () => { ... }),
  // rejectUser: async (userId: string, reason: string) => apiCall(async () => { ... }),

  // NEW BACKEND API CODE - Admin user management
  getPendingUsers: async (): Promise<User[]> => {
    const response = await authenticatedFetch(buildUrl('/api/users/admin/pending'));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  approveUser: async (userId: string): Promise<User> => {
    const response = await authenticatedFetch(buildUrl(`/api/users/${userId}/approve`), {
      method: 'PATCH'
    });
    if (!response.ok) await handleApiError(response);
    const data = await response.json();
    return data.user;
  },

  rejectUser: async (userId: string, reason: string): Promise<User> => {
    const response = await authenticatedFetch(buildUrl(`/api/users/${userId}/reject`), {
      method: 'PATCH',
      body: JSON.stringify({ reason })
    });
    if (!response.ok) await handleApiError(response);
    const data = await response.json();
    return data.user;
  },

  banUser: async (userId: string, reason: string): Promise<User> => {
    const response = await authenticatedFetch(buildUrl(`/api/users/${userId}/ban`), {
      method: 'PATCH',
      body: JSON.stringify({ reason })
    });
    if (!response.ok) await handleApiError(response);
    const data = await response.json();
    return data.user;
  },

  unbanUser: async (userId: string): Promise<User> => {
    const response = await authenticatedFetch(buildUrl(`/api/users/${userId}/unban`), {
      method: 'PATCH'
    });
    if (!response.ok) await handleApiError(response);
    const data = await response.json();
    return data.user;
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getMentors: async () => apiCall(() => {
  //   // ‚úÖ Only return ACTIVE mentors (filter out PENDING_APPROVAL, REJECTED, BANNED)
  //   const allMentors = db.get<Mentor[]>('mentors', INITIAL_MENTORS);
  //   return allMentors.filter(m => m.status === 'ACTIVE');
  // }),

  // NEW BACKEND API CODE
  getMentors: async (): Promise<Mentor[]> => {
    const response = await fetch(buildUrl('/api/mentors'));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.mentors || [];
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getMentorById: async (id: string) => apiCall(() => {
  //   // ‚úÖ Only return mentor if ACTIVE status
  //   const mentor = db.get<Mentor[]>('mentors', INITIAL_MENTORS).find(m => m.id === id);
  //   if (mentor && mentor.status !== 'ACTIVE') return undefined; // Hide non-active mentors
  //   return mentor;
  // }),

  // NEW BACKEND API CODE
  getMentorById: async (id: string): Promise<Mentor | undefined> => {
    const response = await fetch(buildUrl(`/api/mentors/${id}`));

    if (!response.ok) {
      if (response.status === 404) {
        return undefined;
      }
      await handleApiError(response);
    }

    const data = await response.json();
    return data.mentor;
  },

  // NEW BACKEND API CODE - Update mentor profile
  updateMentorProfile: async (
    mentorId: string,
    updates: {
      bio?: string;
      specialties?: string[];
      hourlyRate?: number;
      experienceYears?: number;
      availability?: AvailabilitySlot[];
    }
  ): Promise<any> => {
    const response = await authenticatedFetch(buildUrl(`/api/mentors/${mentorId}/profile`), {
      method: 'PATCH',
      body: JSON.stringify(updates)
    });

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.profile;
  },

  // NEW BACKEND API CODE - Get mentor statistics
  getMentorStats: async (mentorId: string): Promise<any> => {
    const response = await fetch(buildUrl(`/api/mentors/${mentorId}/stats`));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.stats;
  },

  // NEW BACKEND API CODE - Get mentor reviews
  getMentorReviews: async (mentorId: string, limit: number = 10): Promise<any[]> => {
    const response = await fetch(buildUrl(`/api/mentors/${mentorId}/reviews?limit=${limit}`));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.reviews || [];
  },

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getBookings: async (userId: string, role: UserRole) => apiCall(() => {
  //     const all = db.get<Booking[]>('bookings', INITIAL_BOOKINGS);
  //     console.log('üîç [API getBookings] Fetching bookings...');
  //     console.log('  userId:', userId);
  //     console.log('  role:', role);
  //     console.log('  Total bookings in DB:', all.length);
  //     const filtered = all.filter(b => role === UserRole.MENTEE ? b.menteeId === userId : b.mentorId === userId);
  //     console.log('  Filtered bookings:', filtered.length);
  //     console.log('  Details:', filtered.map(b => ({
  //         id: b.id.slice(-6),
  //         menteeId: b.menteeId.slice(0, 3),
  //         mentorId: b.mentorId.slice(0, 3),
  //         type: b.type,
  //         status: b.status
  //     })));
  //     return filtered;
  // }),

  // NEW BACKEND API CODE
  getBookings: async (userId: string, role: UserRole): Promise<Booking[]> => {
    const response = await authenticatedFetch(buildUrl('/api/bookings'));

    if (!response.ok) {
      await handleApiError(response);
    }

    const data = await response.json();
    return data.bookings || [];
  },
  getAllBookings: async () => apiCall(() => db.get<Booking[]>('bookings', INITIAL_BOOKINGS)),
  getSystemSettings: async () => apiCall(() => db.get('settings', INITIAL_SETTINGS)),
  getPricingGroups: async () => apiCall(() => db.get('pricingGroups', INITIAL_PRICING_GROUPS)),
  getPricingCountries: async () => apiCall(() => db.get('pricingCountries', INITIAL_PRICING_COUNTRIES)),
  getMentorLocalizedRate: async (mentorId: string, menteeCountry: string) => apiCall(() => pricingRevenueServiceV2.calculatePrice(mentorId, menteeCountry)),
  calculatePriceDetail: async (mid: string, cid: string) => apiCall(() => {
      const finalPrice = pricingRevenueServiceV2.calculatePrice(mid, cid);
      const sys = db.get<SystemSettings>('settings', INITIAL_SETTINGS);
      return { basePrice: sys.baseLessonCreditPrice, countryMultiplier: 1, groupMultiplier: 1, finalPrice };
  }),
  // Upload avatar file to backend
  uploadFile: async (file: File): Promise<string> => {
    const token = getAuthToken();
    if (!token) throw new Error('Not authenticated');

    const formData = new FormData();
    formData.append('file', file);

    const response = await fetch(`${API_BASE_URL}/api/upload/avatar`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`
        // Don't set Content-Type - browser will set it with boundary for FormData
      },
      body: formData
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: 'Upload failed' }));
      throw new Error(error.message || 'Failed to upload file');
    }

    const data = await response.json();
    return data.user.avatar; // Backend returns updated user with new avatar URL
  },
  
  // --- CHAT SYSTEM ---
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getConversations: async (userId: string, role: UserRole) => apiCall(() => { ... }),
  // getMessages: async (id: string) => apiCall(() => { ... }),
  // sendMessage: async (data: any) => apiCall(() => { ... }),
  // assignConversation: async (id: string, adminId: string) => apiCall(() => { ... }),
  // markAsRead: async (convId: string, role: string) => apiCall(() => { ... }),
  // getUnreadCount: async (userId: string, role: UserRole) => apiCall(() => { ... }),

  // NEW BACKEND API CODE - Messaging
  getConversations: async (userId: string, role: UserRole): Promise<Conversation[]> => {
    const response = await authenticatedFetch(buildUrl('/api/messages/conversations'));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getMessages: async (id: string): Promise<Message[]> => {
    const response = await authenticatedFetch(buildUrl(`/api/messages/conversations/${id}/messages`));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  sendMessage: async (data: { fromId: string; toId: string; content: string; conversationId?: string }): Promise<Message> => {
    const response = await authenticatedFetch(buildUrl('/api/messages/send'), {
      method: 'POST',
      body: JSON.stringify({ receiverId: data.toId, content: data.content })
    });
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  markAsRead: async (convId: string, role: string): Promise<void> => {
    const response = await authenticatedFetch(buildUrl(`/api/messages/conversations/${convId}/mark-read`), {
      method: 'PATCH'
    });
    if (!response.ok) await handleApiError(response);
  },

  getUnreadCount: async (userId: string, role: UserRole): Promise<number> => {
    const response = await authenticatedFetch(buildUrl('/api/messages/unread-count'));
    if (!response.ok) await handleApiError(response);
    const data = await response.json();
    return data.count;
  },

  deleteConversation: async (id: string): Promise<void> => {
    const response = await authenticatedFetch(buildUrl(`/api/messages/conversations/${id}`), {
      method: 'DELETE'
    });
    if (!response.ok) await handleApiError(response);
  },

  // Note: assignConversation removed - backend handles conversation assignment automatically

  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getActiveSubscription: async (userId: string) => apiCall(() => db.get<Subscription[]>('subscriptions', []).find(s => s.menteeId === userId && s.status === 'ACTIVE') || null),

  // NEW BACKEND API CODE - Get active subscription for mentee with specific mentor
  getActiveSubscription: async (userId: string, mentorId: string): Promise<Subscription | null> => {
    const response = await authenticatedFetch(buildUrl(`/api/subscriptions/active/${mentorId}`));

    if (!response.ok) {
      if (response.status === 404) {
        return null;
      }
      await handleApiError(response);
    }

    const data = await response.json();
    return data.subscription || null;
  },
  // OLD MOCKDB CODE - KEPT FOR ROLLBACK
  // getNotifications, getUnreadNotificationCount, markNotificationRead, getLogs, logAction

  // NEW BACKEND API CODE - Notifications (stubs - backend endpoints needed)
  getNotifications: async (userId: string, role: string): Promise<Notification[]> => {
    console.warn('getNotifications: Backend endpoint not implemented');
    return [];
  },

  getUnreadNotificationCount: async (userId: string, role: string): Promise<number> => {
    console.warn('getUnreadNotificationCount: Backend endpoint not implemented');
    return 0;
  },

  markNotificationRead: async (id: string): Promise<void> => {
    console.warn('markNotificationRead: Backend endpoint not implemented');
  },

  // Analytics (admin only)
  getDashboardAnalytics: async (period: 'week' | 'month' | 'year' = 'month'): Promise<any> => {
    const response = await authenticatedFetch(buildUrl(`/api/analytics/dashboard?period=${period}`));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getRevenueAnalytics: async (startDate: string, endDate: string): Promise<any> => {
    const response = await authenticatedFetch(buildUrl(`/api/analytics/revenue?startDate=${startDate}&endDate=${endDate}`));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getUserGrowthAnalytics: async (startDate: string, endDate: string): Promise<any> => {
    const response = await authenticatedFetch(buildUrl(`/api/analytics/users?startDate=${startDate}&endDate=${endDate}`));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  getBookingAnalytics: async (startDate: string, endDate: string): Promise<any> => {
    const response = await authenticatedFetch(buildUrl(`/api/analytics/bookings?startDate=${startDate}&endDate=${endDate}`));
    if (!response.ok) await handleApiError(response);
    return await response.json();
  },

  // System logs - stub (backend handles internally)
  getLogs: async (filter: any): Promise<SystemLog[]> => {
    console.warn('getLogs: Backend endpoint not implemented');
    return [];
  },

  logAction: async (type: string, msg: string, src: string): Promise<void> => {
    console.log(`[${src}] ${type}: ${msg}`);
  }
};

// ==================== FEEDBACK API ====================

export const submitFeedback = async (data: {
  bookingId: string;
  rating: number;
  strengths: string;
  improvements: string;
  nextSteps: string;
  notes?: string;
}) => {
  const response = await fetch('http://localhost:3001/api/feedbacks', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    },
    body: JSON.stringify(data)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to submit feedback');
  }

  return response.json();
};

export const getFeedbackById = async (feedbackId: string) => {
  const response = await fetch(`http://localhost:3001/api/feedbacks/${feedbackId}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to get feedback');
  }

  const result = await response.json();
  return result.data;
};

export const getReceivedFeedbacks = async (options?: {
  page?: number;
  limit?: number;
  mentorId?: string;
}) => {
  const params = new URLSearchParams();
  if (options?.page) params.append('page', options.page.toString());
  if (options?.limit) params.append('limit', options.limit.toString());
  if (options?.mentorId) params.append('mentorId', options.mentorId);

  const response = await fetch(`http://localhost:3001/api/feedbacks/received/list?${params}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to get received feedbacks');
  }

  const result = await response.json();
  return {
    feedbacks: result.data,
    pagination: result.pagination
  };
};

export const getSubmittedFeedbacks = async (options?: {
  page?: number;
  limit?: number;
  menteeId?: string;
}) => {
  const params = new URLSearchParams();
  if (options?.page) params.append('page', options.page.toString());
  if (options?.limit) params.append('limit', options.limit.toString());
  if (options?.menteeId) params.append('menteeId', options.menteeId);

  const response = await fetch(`http://localhost:3001/api/feedbacks/submitted/list?${params}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to get submitted feedbacks');
  }

  const result = await response.json();
  return {
    feedbacks: result.data,
    pagination: result.pagination
  };
};

export const getPendingFeedbacks = async () => {
  const response = await fetch('http://localhost:3001/api/feedbacks/pending/list', {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to get pending feedbacks');
  }

  const result = await response.json();
  return result.data;
};

export const getAllFeedbacks = async (options?: {
  page?: number;
  limit?: number;
  mentorId?: string;
  menteeId?: string;
  startDate?: string;
  endDate?: string;
  minRating?: number;
  maxRating?: number;
}) => {
  const params = new URLSearchParams();
  if (options?.page) params.append('page', options.page.toString());
  if (options?.limit) params.append('limit', options.limit.toString());
  if (options?.mentorId) params.append('mentorId', options.mentorId);
  if (options?.menteeId) params.append('menteeId', options.menteeId);
  if (options?.startDate) params.append('startDate', options.startDate);
  if (options?.endDate) params.append('endDate', options.endDate);
  if (options?.minRating) params.append('minRating', options.minRating.toString());
  if (options?.maxRating) params.append('maxRating', options.maxRating.toString());

  const response = await fetch(`http://localhost:3001/api/feedbacks/all/list?${params}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to get all feedbacks');
  }

  const result = await response.json();
  return {
    feedbacks: result.data,
    pagination: result.pagination
  };
};

export const getFeedbackStats = async () => {
  const response = await fetch('http://localhost:3001/api/feedbacks/stats/summary', {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to get feedback stats');
  }

  const result = await response.json();
  return result.data;
};

export const getOverdueFeedbacks = async () => {
  const response = await fetch('http://localhost:3001/api/feedbacks/overdue/list', {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to get overdue feedbacks');
  }

  const result = await response.json();
  return result.data;
};

function setStore(key: string, data: any) {
    localStorage.setItem(key, JSON.stringify(data));
}
